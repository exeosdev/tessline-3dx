
#ifndef __TS3_SYSTEM_EVENT_SYSTEM_H__
#define __TS3_SYSTEM_EVENT_SYSTEM_H__

#include "eventCommon.h"
#include "sysObject.h"
#include <ts3/math/vector.h>
#include <functional>

namespace ts3::system
{

    ts3SysDeclareHandle( EventController );
    ts3SysDeclareHandle( EventDispatcher );

    struct EventSourceNativeData;

    using EventSourceFindPredicate = std::function<bool( const EventSource & )>;
    using EventSourceNativeDataFindPredicate = std::function<bool( const EventSourceNativeData & )>;

    /// @brief
    enum EventControllerConfigFlagBits : uint32
    {
        E_EVENT_CONTROLLER_CONFIG_FLAG_ENABLE_MOUSE_DOUBLE_CLICK_BIT = 0x0001,
        E_EVENT_CONTROLLER_CONFIG_FLAG_ENABLE_MOUSE_MULTI_CLICK_BIT = 0x0002 | E_EVENT_CONTROLLER_CONFIG_FLAG_ENABLE_MOUSE_DOUBLE_CLICK_BIT,
        E_EVENT_CONTROLLER_CONFIG_FLAGS_DEFAULT = E_EVENT_CONTROLLER_CONFIG_FLAG_ENABLE_MOUSE_MULTI_CLICK_BIT
    };

    class EventSource : public SysObject
    {
        friend class EventController;

    public:
        explicit EventSource( system::SysContextHandle pSysContext );
        virtual ~EventSource() noexcept;

    friendapi:
        void setEventController( EventControllerHandle pEventController );

        void setPrivateData( void * pPrivateData );

        EventSourceNativeData * getEventSourceNativeData() const;

        void * getPrivateData() const;

        template <typename TpOutput>
        TpOutput * getPrivateDataAs() const
        {
            return static_cast<TpOutput *>( _privateData );
        }

    protected:
        void setEventSourceNativeData( EventSourceNativeData & pNativeData );
        void resetEventSourceNativeData();

    private:
        // EventController which handles events generated by this source. A single EventSource may be registered
        // only in one controller at any given time.
        // NOTE: this is an active reference, so the controller is always accessible to a source object.
        EventControllerHandle _eventControllerActiveRef = nullptr;

        // Pointer to a native data (EventSourceNativeData). Defined as void* because we don't bring any *Native*
        // definitions into public namespace. Each specific Source sub-class (a window, a surface, etc.) can have
        // its own way to provide this.
        EventSourceNativeData * _eventSourceNativeData = nullptr;

        void * _privateData = nullptr;
    };

    class EventDispatcher : public SysObject
    {
    public:
        struct ObjectInternalData;
        EventController * const mEventController = nullptr;
        std::unique_ptr<ObjectInternalData> const mInternal;

        explicit EventDispatcher( EventControllerHandle pEventController );
        virtual ~EventDispatcher() noexcept;

        void bindEventHandler( EEventBaseType pBaseType, EventHandler pHandler );
        void bindEventHandler( EEventCategory pCategory, EventHandler pHandler );
        void bindEventHandler( EEventCodeIndex pCodeIndex, EventHandler pHandler );
        void bindDefaultEventHandler( EventHandler pHandler );

        void resetHandlers();

        void setIdleProcessingMode( bool pIdle );

        bool postEvent( EventObject pEvent );
        bool postEvent( event_code_value_t pEventCode );
        bool postEventAppQuit();
        bool postEventAppTerminate();

    private:
        void _preProcessEvent( EventObject & pEvent );
        void _putEvent( EventObject & pEvent );

    private:
        EventControllerHandle _eventControllerActiveRef = nullptr;
    };

	class EventController : public SysObject
	{
	    friend class EventDispatcher;
	    friend class EventSource;

	public:
	    struct ObjectInternalData;
	    std::unique_ptr<ObjectInternalData> const mInternal;

	public:
	    explicit EventController( system::SysContextHandle pSysContext );
		virtual ~EventController() noexcept;

		bool dispatchEvent( EventObject pEvent );

		uint32 updateSysQueueAuto();
		uint32 updateSysQueuePeek( uint32 pLimit = CX_INT32_MAX );
		uint32 updateSysQueueWait( uint32 pLimit = CX_INT32_MAX );

		TS3_PCL_ATTR_NO_DISCARD EventDispatcherHandle createEventDispatcher();

		bool setActiveEventDispatcher( EventDispatcher & pEventDispatcher );
		bool resetActiveEventDispatcher();

		void registerEventSource( EventSource & pEventSource );
		void unregisterEventSource( EventSource & pEventSource );

        TS3_PCL_ATTR_NO_DISCARD EventSource * findEventSource( const EventSourceFindPredicate & pPredicate ) const;

        TS3_PCL_ATTR_NO_DISCARD EventSource * findEventSource( const EventSourceNativeDataFindPredicate & pPredicate ) const;

        TS3_PCL_ATTR_NO_DISCARD bool isEventSourceRegistered( EventSource & pEventSource ) const;

		TS3_PCL_ATTR_NO_DISCARD bool hasActiveDispatcher() const;

	friendapi:
		// Used by the EventSource class. It is called inside its destructor.
		void onEventSourceDestroy( EventSource & pEventSource ) noexcept;

		// Used by the EventDispatcher class. It is called inside its destructor.
		void onEventDispatcherDestroy( EventDispatcher & pEventDispatcher ) noexcept;

	private:
	    void _checkActiveDispatcherState();
	    void _onActiveDispatcherChange( EventDispatcher * pEventDispatcher );
	    void _validateDispatcher( EventDispatcher & pEventDispatcher );
	    void _addEventDispatcher( EventDispatcher & pEventDispatcher );
	    void _removeEventDispatcher( EventDispatcher & pEventDispatcher );
	    void _addEventSource( EventSource & pEventSource );
	    void _removeEventSource( EventSource & pEventSource );
	    void _resetEventDispatcherList();
	    void _resetEventSourceList();

	    void _nativeConstructor();
	    void _nativeDestructor() noexcept;
	    void _nativeRegisterEventSource( EventSource & pEventSource );
	    void _nativeUnregisterEventSource( EventSource & pEventSource );
	    bool _nativeUpdateSysQueue();
	    bool _nativeUpdateSysQueueWait();
	    void _nativeOnActiveDispatcherChange( EventDispatcher * pEventDispatcher );
	};

} // namespace ts3::system

#endif // __TS3_SYSTEM_EVENT_SYSTEM_H__
